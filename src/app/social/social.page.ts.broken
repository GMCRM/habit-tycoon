import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import { 
  IonContent, IonHeader, IonTitle, IonToolbar,
  IonCard, IonCardContent, IonSegment, IonSegmentButton,
  IonButton, IonIcon, IonLabel, IonBadge, IonSpinner, ToastController, AlertController
} from '@ionic/angular/standalone';
import { AuthService } from '../services/auth.service';

import { SocialService, Friend } from '../services/social.service';
import { HabitBusinessService } from '../services/habit-business.service';
import { BottomNavComponent } from '../shared/bottom-nav/bottom-nav.component';
import { addIcons } from 'ionicons';
import { 
  people, personAdd, arrowBack, medalOutline, star, checkmarkCircle, business,
  notifications, checkmark, close, notificationsOutline
} from 'ionicons/icons';

@Component({
  selector: 'app-social',
  templateUrl: './social.page.html',
  styleUrls: ['./social.page.scss'],
  standalone: true,
    imports: [
    IonContent, IonHeader, IonTitle, IonToolbar,
    IonCard, IonSegment, IonSegmentButton,
    IonCardContent, IonButton, IonIcon, IonLabel, IonBadge, IonSpinner,
    BottomNavComponent, CommonModule
  ],
})
export class SocialPage implements OnInit {
  private isInitialized = false;
  
  currentUser: any = null;
  userProfile: any = null;
  selectedSegment: 'friends' | 'requests' | 'leaderboard' = 'friends';
  
  // Social data
  friends: Friend[] = [];
  pendingRequests: any[] = [];
  sentRequests: any[] = [];
  friendsLeaderboard: any[] = [];
  
  // UI state
  isLoading = false;
  
  constructor(
    private router: Router,
    private authService: AuthService,
    private socialService: SocialService,
    private habitBusinessService: HabitBusinessService,
    private toastController: ToastController,
    private alertController: AlertController
  ) {
    addIcons({people,notificationsOutline,notifications,medalOutline,personAdd,checkmark,close,arrowBack,star,checkmarkCircle,business});
  }

  async ionViewWillEnter() {
    console.log('üîç SocialPage: ionViewWillEnter');
    
    // Always ensure data is loaded when entering the view
    if (!this.isInitialized) {
      await this.initializePage();
    } else {
      // Refresh data if already initialized
      await this.loadSocialData();
    }
  }

  async initializePage() {
    console.log('üîç SocialPage: initializePage started');
    
    if (this.isInitialized) {
      console.log('üîç SocialPage: Already initialized in initializePage, skipping');
      return;
    }
    
    this.isLoading = true;
    
    try {
      console.log('üîç SocialPage: Loading current user...');
      await this.loadCurrentUser();
      
      if (this.currentUser) {
        console.log('‚úÖ SocialPage: User found, loading social data...');
        await this.loadSocialData();
        console.log('‚úÖ SocialPage: Social data loaded successfully');
        this.isInitialized = true;
      } else {
        console.log('‚ùå SocialPage: No user found, redirecting to login');
        this.router.navigate(['/login']);
        return;
      }
    } catch (error) {
      console.error('‚ùå SocialPage: Error initializing social page:', error);
      // Don't redirect on initialization errors, just show empty state
    } finally {
      this.isLoading = false;
      console.log('‚úÖ SocialPage: Initialization complete');
    }
  }

  async ngOnInit() {
    console.log('üîç SocialPage: ngOnInit started');
    
    // Prevent double initialization
    if (this.isInitialized) {
      console.log('üîç SocialPage: Already initialized, skipping');
      return;
    }
    
    // Always initialize when the component is created
    // The ionViewWillEnter will handle refreshing if needed
    await this.initializePage();
  }

  async loadCurrentUser() {
    try {
      console.log('üîç SocialPage: Loading current user...');
      const { data: { user }, error: userError } = await this.authService.getUser();
      
      if (userError) {
        console.error('‚ùå SocialPage: Error getting user from auth:', userError);
        this.currentUser = null;
        return;
      }
      
      this.currentUser = user;
      console.log('‚úÖ SocialPage: User loaded successfully:', user?.id);
      
      // Load user profile (but don't fail if this doesn't work)
      if (user) {
        try {
          const { data: profile, error } = await this.authService.supabase
            .from('user_profiles')
            .select('*')
            .eq('id', user.id)
            .single();
          
          if (error) {
            console.log('‚ö†Ô∏è SocialPage: User profile not found, will use defaults:', error.message);
            this.userProfile = null;
          } else {
            this.userProfile = profile;
            console.log('User profile loaded:', profile.name);
          }
        } catch (profileError) {
          console.log('Error loading user profile, continuing without it:', profileError);
          this.userProfile = null;
        }
      }
    } catch (error) {
      console.error('Error in loadCurrentUser:', error);
      this.currentUser = null;
    }
  }

  async loadSocialData() {
    if (!this.currentUser) {
      console.log('No current user, skipping social data load');
      return;
    }
    
    console.log('Loading social data for user:', this.currentUser.id);
    
    try {
      // Load friends, friend requests, and leaderboard data
      // Handle each request separately to avoid one failure breaking everything
      const [friends, pendingRequests, sentRequests, leaderboard] = await Promise.allSettled([
        this.socialService.getFriends(this.currentUser.id),
        this.socialService.getPendingRequests(this.currentUser.id),
        this.socialService.getSentRequests(this.currentUser.id),
        this.socialService.getFriendsLeaderboard(this.currentUser.id)
      ]);
      
      // Extract results or use fallbacks
      this.friends = friends.status === 'fulfilled' ? friends.value : [];
      this.pendingRequests = pendingRequests.status === 'fulfilled' ? pendingRequests.value : [];
      this.sentRequests = sentRequests.status === 'fulfilled' ? sentRequests.value : [];
      this.friendsLeaderboard = leaderboard.status === 'fulfilled' ? leaderboard.value : [];
      
      console.log('Social data loaded:', { 
        friends: this.friends.length, 
        pendingRequests: this.pendingRequests.length, 
        sentRequests: this.sentRequests.length, 
        leaderboard: this.friendsLeaderboard.length 
      });

      // Debug: Check what profiles actually exist in the database
      try {
        const { data: allProfiles, error: profilesError } = await this.authService.supabase
          .rpc('debug_user_profiles');
        
        console.log('üîç All user profiles in database:', allProfiles);
        if (profilesError) {
          console.error('‚ùå Error fetching all profiles:', profilesError);
        }
      } catch (debugError) {
        console.log('Debug function not available yet:', debugError);
      }      // If leaderboard failed or is empty, create a simple fallback with just the user
      if (leaderboard.status === 'rejected' || this.friendsLeaderboard.length === 0) {
        console.log('Creating fallback leaderboard with current user');
        this.friendsLeaderboard = [{
          id: this.currentUser.id,
          name: 'You',
          net_worth: this.userProfile?.net_worth || 0,
          rank: 1
        }];
      }
      
    } catch (error) {
      console.error('Error loading social data:', error);
      // Set safe fallbacks instead of crashing
      this.friends = [];
      this.notifications = [];
      this.pendingRequests = [];
      this.sentRequests = [];
      this.friendsLeaderboard = [{
        id: this.currentUser.id,
        name: 'You',
        net_worth: this.userProfile?.net_worth || 0,
        rank: 1
      }];
    }
  }

  onSegmentChange(event: any) {
    this.selectedSegment = event.detail.value;
  }

  goBack() {
    this.router.navigate(['/home']);
  }

  async addFriend() {
    const alert = await this.alertController.create({
      header: 'Add Friend',
      message: 'Enter your friend\'s username or email:',
      inputs: [
        {
          name: 'identifier',
          type: 'text',
          placeholder: 'Username or email'
        }
      ],
      buttons: [
        {
          text: 'Cancel',
          role: 'cancel'
        },
        {
          text: 'Debug: Show All Users',
          handler: async () => {
            try {
              console.log('üîç Debug: Starting user profile check...');
              console.log('Current user:', this.currentUser);
              
              // Get all user profiles and current user info
              const { data: profiles, error } = await this.authService.supabase
                .from('user_profiles')
                .select('email, name, id, created_at')
                .order('created_at', { ascending: false })
                .limit(20);
              
              console.log('Profiles query result:', { profiles, error });
              
              // Also check count
              const { count, error: countError } = await this.authService.supabase
                .from('user_profiles')
                .select('*', { count: 'exact', head: true });
              
              console.log('Profiles count result:', { count, countError });
              
              let userList = '';
              
              if (error) {
                userList = `‚ùå Error loading profiles: ${error.message}\n`;
                userList += `Code: ${error.code}\n`;
                userList += `Details: ${error.details}\n`;
                userList += `Hint: ${error.hint}`;
              } else {
                userList = `üìä DATABASE STATUS:\n`;
                userList += `Total rows: ${count ?? 'unknown'}\n`;
                userList += `Returned: ${profiles?.length || 0}\n\n`;
                
                if (profiles && profiles.length > 0) {
                  userList += `ALL USER PROFILES (${profiles.length} found):\n\n`;
                  profiles.forEach((profile, index) => {
                    const isCurrentUser = profile.id === this.currentUser?.id;
                    const marker = isCurrentUser ? ' ‚Üê YOU' : '';
                    userList += `${index + 1}. ${profile.name || 'No name'}\n`;
                    userList += `   ID: ${profile.id?.substring(0, 8)}...${marker}\n`;
                    userList += `   Email: ${profile.email}${marker}\n`;
                    userList += `   Created: ${profile.created_at || 'Unknown'}\n\n`;
                  });
                } else {
                  userList += `‚ùå NO USER PROFILES FOUND!\n\n`;
                  userList += `This means:\n`;
                  userList += `‚Ä¢ Database is empty OR\n`;
                  userList += `‚Ä¢ RLS policies blocking access OR\n`;
                  userList += `‚Ä¢ Profiles not created properly\n\n`;
                  userList += `Current user ID: ${this.currentUser?.id?.substring(0, 8)}...\n`;
                  userList += `Current user email: ${this.currentUser?.email}`;
                }
              }
              
              const debugAlert = await this.alertController.create({
                header: 'Advanced Debug Info',
                message: userList,
                buttons: [
                  'OK',
                  {
                    text: 'Check Friend Requests',
                    handler: async () => {
                      await this.debugFriendRequests();
                    }
                  },
                  {
                    text: 'Create My Profile',
                    handler: async () => {
                      await this.createCurrentUserProfile();
                    }
                  },
                  {
                    text: 'Refresh Data',
                    handler: async () => {
                      await this.loadSocialData();
                      const toast = await this.toastController.create({
                        message: 'üîÑ Social data refreshed!',
                        duration: 1500,
                        color: 'primary'
                      });
                      await toast.present();
                    }
                  }
                ]
              });
              await debugAlert.present();
            } catch (error) {
              console.error('Error fetching users:', error);
              const errorAlert = await this.alertController.create({
                header: 'Debug Error',
                message: `Failed to fetch users: ${(error as any)?.message}\n\nCheck console for details.`,
                buttons: ['OK']
              });
              await errorAlert.present();
            }
          }
        },
        {
          text: 'Send Request',
          handler: async (data: any) => {
            if (!data.identifier.trim()) return;
            
            try {
              await this.socialService.sendFriendRequest(this.currentUser.id, data.identifier.trim());
              
              const toast = await this.toastController.create({
                message: 'üë• Friend request sent!',
                duration: 2000,
                color: 'success'
              });
              await toast.present();
              
              // Refresh social data
              await this.loadSocialData();
              
            } catch (error) {
              console.error('Error sending friend request:', error);
              const toast = await this.toastController.create({
                message: error instanceof Error ? error.message : 'Failed to send friend request',
                duration: 3000,
                color: 'danger'
              });
              await toast.present();
            }
          }
        }
      ]
    });

    await alert.present();
  }

  async acceptRequest(requestId: string) {
    try {
      await this.socialService.acceptFriendRequest(requestId);
      
      const toast = await this.toastController.create({
        message: '‚úÖ Friend request accepted!',
        duration: 2000,
        color: 'success'
      });
      await toast.present();
      
      // Refresh social data
      await this.loadSocialData();
      
    } catch (error) {
      console.error('Error accepting friend request:', error);
      const toast = await this.toastController.create({
        message: 'Failed to accept friend request',
        duration: 3000,
        color: 'danger'
      });
      await toast.present();
    }
  }

  async declineRequest(requestId: string) {
    try {
      await this.socialService.declineFriendRequest(requestId);
      
      const toast = await this.toastController.create({
        message: '‚ùå Friend request declined',
        duration: 2000,
        color: 'medium'
      });
      await toast.present();
      
      // Refresh social data
      await this.loadSocialData();
      
    } catch (error) {
      console.error('Error declining friend request:', error);
      const toast = await this.toastController.create({
        message: 'Failed to decline friend request',
        duration: 3000,
        color: 'danger'
      });
      await toast.present();
    }
  }

  formatTimeAgo(date: string): string {
    const now = new Date();
    const postDate = new Date(date);
    const diffMs = now.getTime() - postDate.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffHours < 1) {
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      return `${diffMinutes}m ago`;
    } else if (diffHours < 24) {
      return `${diffHours}h ago`;
    } else if (diffDays < 7) {
      return `${diffDays}d ago`;
    } else {
      return postDate.toLocaleDateString();
    }
  }

  }
}

  async createCurrentUserProfile() {
    try {
      if (!this.currentUser) {
        throw new Error('No current user found');
      }
      
      console.log('Creating profile for current user...');
      
      // Check if profile already exists
      const { data: existingProfile } = await this.authService.supabase
        .from('user_profiles')
        .select('id')
        .eq('id', this.currentUser.id)
        .single();
      
      if (existingProfile) {
        const toast = await this.toastController.create({
          message: '‚úÖ Profile already exists!',
          duration: 2000,
          color: 'success'
        });
        await toast.present();
        return;
      }
      
      // Create profile for current user
      const { error } = await this.authService.supabase
        .from('user_profiles')
        .insert({
          id: this.currentUser.id,
          email: this.currentUser.email,
          name: this.currentUser.user_metadata?.['name'] || this.currentUser.email?.split('@')[0] || 'User',
          cash: 100, // Starting cash
          net_worth: 100
        });
      
      if (error) {
        throw error;
      }
      
      console.log(`‚úÖ Created profile for ${this.currentUser.email}`);
      
      const toast = await this.toastController.create({
        message: '‚úÖ Profile created successfully!',
        duration: 3000,
        color: 'success'
      });
      await toast.present();
      
      // Reload user profile
      await this.loadCurrentUser();
      
    } catch (error) {
      console.error('Error creating current user profile:', error);
      const toast = await this.toastController.create({
        message: 'Failed to create profile: ' + (error as any)?.message,
        duration: 4000,
        color: 'danger'
      });
      await toast.present();
    }
  }

  async debugFriendRequests() {
    try {
      console.log('üîç Debug: Checking friend requests...');
      
      // Check all friendships in the database for current user
      const { data: allFriendships, error } = await this.authService.supabase
        .from('friendships')
        .select(`
          *,
          sender_profile:user_profiles!friendships_user_id_fkey(id, name, email),
          recipient_profile:user_profiles!friendships_friend_id_fkey(id, name, email)
        `)
        .or(`user_id.eq.${this.currentUser.id},friend_id.eq.${this.currentUser.id}`);
      
      console.log('All friendships for user:', allFriendships);
      
      let debugMessage = `üîç FRIEND REQUESTS DEBUG\n`;
      debugMessage += `Current user: ${this.currentUser.email}\n`;
      debugMessage += `User ID: ${this.currentUser.id.substring(0, 8)}...\n\n`;
      
      if (error) {
        debugMessage += `‚ùå Error: ${error.message}\n`;
        debugMessage += `Code: ${error.code}\n`;
        debugMessage += `Details: ${error.details}`;
      } else if (allFriendships && allFriendships.length > 0) {
        debugMessage += `üìä Found ${allFriendships.length} friendship(s):\n\n`;
        
        allFriendships.forEach((friendship, index) => {
          const isIncoming = friendship.friend_id === this.currentUser.id;
          const isOutgoing = friendship.user_id === this.currentUser.id;
          
          debugMessage += `${index + 1}. ${friendship.status.toUpperCase()}\n`;
          debugMessage += `   ID: ${friendship.id}\n`;
          
          if (isIncoming) {
            debugMessage += `   Type: INCOMING REQUEST\n`;
            debugMessage += `   From: ${friendship.sender_profile?.name || 'Unknown'}\n`;
            debugMessage += `   Email: ${friendship.sender_profile?.email}\n`;
          } else if (isOutgoing) {
            debugMessage += `   Type: OUTGOING REQUEST\n`;
            debugMessage += `   To: ${friendship.recipient_profile?.name || 'Unknown'}\n`;
            debugMessage += `   Email: ${friendship.recipient_profile?.email}\n`;
          }
          
          debugMessage += `   Created: ${friendship.created_at}\n\n`;
        });
        
        // Show current arrays
        debugMessage += `\nüìù Current Data Arrays:\n`;
        debugMessage += `Pending Requests: ${this.pendingRequests.length}\n`;
        debugMessage += `Sent Requests: ${this.sentRequests.length}\n`;
        debugMessage += `Friends: ${this.friends.length}\n`;
        
      } else {
        debugMessage += `‚ùå No friendships found in database\n`;
        debugMessage += `This means no friend requests have been sent or received.`;
      }
      
      const debugAlert = await this.alertController.create({
        header: 'Friend Requests Debug',
        message: debugMessage,
        buttons: [
          'OK',
          {
            text: 'Refresh & Reload',
            handler: async () => {
              await this.loadSocialData();
              const toast = await this.toastController.create({
                message: 'üîÑ Social data reloaded!',
                duration: 1500,
                color: 'primary'
              });
              await toast.present();
            }
          }
        ]
      });
      await debugAlert.present();
      
    } catch (error) {
      console.error('Error debugging friend requests:', error);
      const errorAlert = await this.alertController.create({
        header: 'Debug Error',
        message: `Failed to debug friend requests: ${(error as any)?.message}`,
        buttons: ['OK']
      });
      await errorAlert.present();
    }
  }

  // Getter methods for template use
  get unreadNotificationsCount(): number {
    return this.notifications.filter(n => !n.is_read).length;
  }

  get hasUnreadNotifications(): boolean {
    return this.unreadNotificationsCount > 0;
  }
}
